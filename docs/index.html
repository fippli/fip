<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Fip Language Documentation</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body id="top">
    <nav>
      <input type="text" id="nav-filter" placeholder="Filter headings..." />
      <ul id="nav-list">
      <li data-nav-item>
        <a href="#overview-overview">Overview</a>
        <ul>
          <li data-nav-item><a href="#overview-basic-structure">Basic structure</a></li>
          <li data-nav-item><a href="#overview-evaluation-model">Evaluation model</a></li>
          <li data-nav-item><a href="#overview-functions-and-currying">Functions and currying</a></li>
          <li data-nav-item><a href="#overview-purity-markers">Purity markers</a></li>
          <li data-nav-item><a href="#overview-comments">Comments</a></li>
          <li data-nav-item><a href="#overview-modules-and-imports">Modules and imports</a></li>
          <li data-nav-item><a href="#overview-putting-it-together">Putting it together</a></li>
        </ul>
      </li>
      <li data-nav-item>
        <a href="#variables-variables">Variables</a>
        <ul>
          <li data-nav-item><a href="#variables-bindings">Bindings</a></li>
          <li data-nav-item><a href="#variables-symbols">Symbols</a></li>
        </ul>
      </li>
      <li data-nav-item>
        <a href="#data-types-data-types">Data Types</a>
        <ul>
          <li data-nav-item><a href="#data-types-strings">Strings</a></li>
          <li data-nav-item><a href="#data-types-numbers">Numbers</a></li>
          <li data-nav-item><a href="#data-types-boolean">Boolean</a></li>
          <li data-nav-item><a href="#data-types-null">Null</a></li>
        </ul>
      </li>
      <li data-nav-item>
        <a href="#operators-operators">Operators</a>
        <ul>
          <li data-nav-item><a href="#operators-assignment">Assignment :</a></li>
          <li data-nav-item><a href="#operators-addition">Addition +</a></li>
          <li data-nav-item><a href="#operators-subtraction">Subtraction -</a></li>
          <li data-nav-item><a href="#operators-multiplication">Multiplication *</a></li>
          <li data-nav-item><a href="#operators-division">Division /</a></li>
          <li data-nav-item><a href="#operators-equality">Equality =</a></li>
          <li data-nav-item><a href="#operators-not-equal">Not equal ≠</a></li>
          <li data-nav-item><a href="#operators-less-than">Less than &lt;</a></li>
          <li data-nav-item><a href="#operators-greater-than">Greater than &gt;</a></li>
          <li data-nav-item><a href="#operators-less-than-or-equal">Less than or equal &lt;=</a></li>
          <li data-nav-item><a href="#operators-greater-than-or-equal">Greater than or equal &gt;=</a></li>
          <li data-nav-item><a href="#operators-logical-and">Logical and &amp;</a></li>
          <li data-nav-item><a href="#operators-logical-or">Logical or |</a></li>
          <li data-nav-item><a href="#operators-spread">Spread ...</a></li>
        </ul>
      </li>
      <li data-nav-item>
        <a href="#functions-functions">Functions</a>
        <ul>
          <li data-nav-item><a href="#functions-definition">Definition</a></li>
          <li data-nav-item><a href="#functions-function-call">Function call</a></li>
          <li data-nav-item><a href="#functions-anonymous-functions">Anonymous functions</a></li>
          <li data-nav-item><a href="#functions-composable-blocks">Composable blocks</a></li>
          <li data-nav-item><a href="#functions-function-notations">Function notations</a></li>
        </ul>
      </li>
      <li data-nav-item>
        <a href="#core-core-functions">Core Functions</a>
        <ul>
          <li data-nav-item><a href="#core-reference-guides">Reference Guides</a></li>
        </ul>
      </li>
      <li data-nav-item>
        <a href="#data-structures-data-structures">Data Structures</a>
        <ul>
          <li data-nav-item><a href="#data-structures-objects">Objects</a></li>
          <li data-nav-item><a href="#data-structures-arrays">Arrays</a></li>
        </ul>
      </li>
      <li data-nav-item>
        <a href="#imports-imports">Imports</a>
        <ul>
          <li data-nav-item><a href="#imports-basic-syntax">Basic syntax</a></li>
          <li data-nav-item><a href="#imports-semantics">Semantics</a></li>
          <li data-nav-item><a href="#imports-namespace-imports">Namespace imports</a></li>
          <li data-nav-item><a href="#imports-selective-imports">Selective imports</a></li>
          <li data-nav-item><a href="#imports-error-handling">Error handling</a></li>
        </ul>
      </li>
      <li data-nav-item>
        <a href="#errors-errors">Errors</a>
        <ul>
          <li data-nav-item><a href="#errors-doesnt-make-sense">Doesn&#39;t make sense</a></li>
          <li data-nav-item><a href="#errors-suffix-error">Suffix error</a></li>
          <li data-nav-item><a href="#errors-mutation-error">Mutation error</a></li>
        </ul>
      </li>
      <li data-nav-item>
        <a href="#comments-comments">Comments</a>
        <ul>
          <li data-nav-item><a href="#comments-single-line-comments">Single-line comments</a></li>
        </ul>
      </li>
      <li data-nav-item>
        <a href="#array-core-array-helpers">Core Array Helpers</a>
        <ul>
          <li data-nav-item><a href="#array-map">map</a></li>
          <li data-nav-item><a href="#array-reduce">reduce</a></li>
          <li data-nav-item><a href="#array-filter">filter</a></li>
          <li data-nav-item><a href="#array-every">every?</a></li>
          <li data-nav-item><a href="#array-some">some?</a></li>
          <li data-nav-item><a href="#array-none">none?</a></li>
        </ul>
      </li>
      <li data-nav-item>
        <a href="#control-core-control">Core Control</a>
        <ul>
          <li data-nav-item><a href="#control-if">if</a></li>
        </ul>
      </li>
      <li data-nav-item>
        <a href="#effects-core-effects">Core Effects</a>
        <ul>
          <li data-nav-item><a href="#effects-log">log!</a></li>
          <li data-nav-item><a href="#effects-trace">trace!</a></li>
          <li data-nav-item><a href="#effects-for-each">for-each!</a></li>
        </ul>
      </li>
      <li data-nav-item>
        <a href="#identity-core-identity">Core Identity</a>
        <ul>
          <li data-nav-item><a href="#identity-identity">identity</a></li>
        </ul>
      </li>
      <li data-nav-item>
        <a href="#math-core-math">Core Math</a>
        <ul>
          <li data-nav-item><a href="#math-add">add</a></li>
          <li data-nav-item><a href="#math-subtract">subtract</a></li>
          <li data-nav-item><a href="#math-multiply">multiply</a></li>
          <li data-nav-item><a href="#math-divide">divide</a></li>
          <li data-nav-item><a href="#math-divide-by">divide-by</a></li>
          <li data-nav-item><a href="#math-increment">increment</a></li>
          <li data-nav-item><a href="#math-decrement">decrement</a></li>
        </ul>
      </li>
      <li data-nav-item>
        <a href="#object-core-object-helpers">Core Object Helpers</a>
      </li>
      <li data-nav-item>
        <a href="#values-core-values">Core Values</a>
        <ul>
          <li data-nav-item><a href="#values-map">.map</a></li>
          <li data-nav-item><a href="#values-defined">defined?</a></li>
        </ul>
      </li>
      </ul>
    </nav>
    <script>
      (function() {
        const filterInput = document.getElementById('nav-filter');
        const navList = document.getElementById('nav-list');
        const navItems = navList.querySelectorAll('[data-nav-item]');
        
        filterInput.addEventListener('input', function(e) {
          const filter = e.target.value.toLowerCase().trim();
          
          navItems.forEach(function(item) {
            const link = item.querySelector('a');
            if (!link) return;
            
            const text = link.textContent.toLowerCase();
            const matches = text.includes(filter);
            
            if (matches) {
              item.style.display = '';
              // Show parent H1 if H2 matches
              const parentLi = item.closest('li[data-nav-item]');
              if (parentLi && parentLi !== item) {
                parentLi.style.display = '';
              }
            } else {
              item.style.display = filter === '' ? '' : 'none';
            }
          });
          
          // Hide H1 items if all their H2 children are hidden
          navList.querySelectorAll('> li[data-nav-item]').forEach(function(h1Item) {
            const h2List = h1Item.querySelector('ul');
            if (h2List) {
              const visibleH2s = Array.from(h2List.querySelectorAll('li[data-nav-item]'))
                .filter(function(li) { return li.style.display !== 'none'; });
              const hasVisibleH2s = visibleH2s.length > 0;
              const h1Link = h1Item.querySelector('> a');
              const h1Matches = h1Link && h1Link.textContent.toLowerCase().includes(filter);
              
              if (!hasVisibleH2s && !h1Matches && filter !== '') {
                h1Item.style.display = 'none';
              } else {
                h1Item.style.display = '';
              }
            }
          });
        });
      })();
    </script>
    <main>
      <section id="section-overview" data-doc-section="section-overview" data-source="/Users/filipjohansson/dev/fippli/fip/syntax/overview.md">
<h1 id="overview-overview">Overview</h1>
<p>FIP programs are sequences of expressions evaluated from top to bottom. Each binding introduces a new name, every expression produces a value, and functions are curried by default. This overview walks through the essential pieces you need before digging into the detailed specification sections.</p>
<h2 id="overview-basic-structure">Basic structure</h2>
<ul>
<li>Files use the <code>.fip</code> extension.</li>
<li>Newline-separated expressions run in order; the value from one line can feed into the next when used inside composable blocks.</li>
<li>Bindings use the <code>name: expression</code> syntax and are immutable for the lifetime of their scope.</li>
</ul>
<pre><code>// hello.fip
name: &quot;Filip&quot;
// -&gt; &quot;Filip&quot;

message: &quot;Hello, &lt;name&gt;!&quot;
// -&gt; &quot;Hello, Filip!&quot;

log!(message)
// -&gt; null
</code></pre>
<h2 id="overview-evaluation-model">Evaluation model</h2>
<ol>
<li>Bindings evaluate lazily within composable blocks, otherwise eagerly on assignment.</li>
<li>Attempting to reassign an existing name in the same scope is a compile-time error.</li>
<li>All functions return the value of their final expression; no implicit <code>return</code> keyword exists.</li>
</ol>
<h2 id="overview-functions-and-currying">Functions and currying</h2>
<p>Functions follow <code>fn-name: (arg1, arg2) { body }</code>. Multiple parameters are syntactic sugar for nested single-argument functions, so partial application works everywhere.</p>
<pre><code>add: (x, y) { x + y }
// -&gt; &lt;function&gt;

add-one: add(1)
// -&gt; &lt;function awaiting y&gt;

add-one(4)
// -&gt; 5
</code></pre>
<p>Anonymous functions drop the name but keep the same parameter and body structure: <code>(x) { x + 1 }</code>.</p>
<h2 id="overview-purity-markers">Purity markers</h2>
<ul>
<li>Append <code>!</code> to a function name or parameter list when it performs side effects (<code>log!</code>, <code>for-each!</code>). Impure functions can only be called from other impure functions.</li>
<li>Append <code>?</code> when a function returns a boolean (<code>defined?</code>, <code>is-zero?</code>). Marking a non-boolean function with <code>?</code> is a compile-time error.</li>
</ul>
<h2 id="overview-comments">Comments</h2>
<p>Single-line comments start with <code>//</code> and continue to the end of the line. There is no block comment syntax yet.</p>
<pre><code>// Print each number after doubling it
numbers: [1, 2, 3]
// -&gt; [1, 2, 3]

for-each!((n)! {
  doubled: n * 2
  log!(doubled)
}, numbers)
// -&gt; null
</code></pre>
<h2 id="overview-modules-and-imports">Modules and imports</h2>
<p>Use <code>use</code> statements to pull definitions from other files. Relative imports resolve from the current file's directory, and names are immutable just like local bindings.</p>
<pre><code>use math.add from &quot;./lib/math&quot;

result: add(2, 3)
// -&gt; 5
</code></pre>
<h2 id="overview-putting-it-together">Putting it together</h2>
<p>A typical program weaves bindings, function calls, and composable blocks:</p>
<pre><code>// Calculate the total cost with tax and log the steps
tax-rate: 0.25
// -&gt; 0.25

items: [10, 20, 40]
// -&gt; [10, 20, 40]

subtotal: items
  reduce((total, price) { total + price }, 0)
// -&gt; 70

total: subtotal * (1 + tax-rate)
// -&gt; 87.5

trace!(&quot;subtotal&quot;, subtotal)
// -&gt; 70

trace!(&quot;total&quot;, total)
// -&gt; 87.5
</code></pre>

</section>
<section id="section-variables" data-doc-section="section-variables" data-source="/Users/filipjohansson/dev/fippli/fip/syntax/variables.md">
<h1 id="variables-variables">Variables</h1>
<p>FIP bindings are immutable by design, keeping program flow predictable. When you bind a name to a value, that relationship stays fixed for the scope unless you intentionally shadow it in a narrower block. This section covers how to declare bindings and how to name them consistently.</p>
<h2 id="variables-bindings">Bindings</h2>
<p><strong>Signature</strong> <code>name: expression -&gt; value</code></p>
<p><strong>Behavior</strong> Evaluates <code>expression</code> and binds the result to <code>name</code>. Rebinding the same name in the same scope raises a compile-time error. Use new identifiers to represent derived values.</p>
<p><strong>Example</strong></p>
<pre><code>count: 3
// -&gt; 3

next-count: count + 1
// -&gt; 4

count: 4
// -&gt; error: cannot reassign 'count' in the same scope
</code></pre>
<h2 id="variables-symbols">Symbols</h2>
<p><strong>Signature</strong> <code>&lt;segment-1&gt;-&lt;segment-2&gt;-...</code></p>
<p><strong>Behavior</strong> Symbol names must be lower-case kebab case. Hyphenated segments improve readability and align with standard library naming. Names ending with <code>!</code> or <code>?</code> follow the purity and predicate conventions respectively.</p>
<p><strong>Example</strong></p>
<pre><code>user-name: &quot;Filip&quot;
// -&gt; &quot;Filip&quot;

is-active?: (flag) { flag }
// -&gt; &lt;function&gt;

trace-action!: (message) { log!(message) }
// -&gt; &lt;function&gt;
</code></pre>

</section>
<section id="section-data-types" data-doc-section="section-data-types" data-source="/Users/filipjohansson/dev/fippli/fip/syntax/data-types.md">
<h1 id="data-types-data-types">Data Types</h1>
<p>FIP programs operate on a small set of core value kinds. Each type enforces immutable semantics and interoperates with language helpers such as comparison operators and destructuring. This page summarizes the built-in types and shows how they behave.</p>
<h2 id="data-types-strings">Strings</h2>
<p><strong>Signature</strong> <code>&quot;text&quot;</code></p>
<p><strong>Behavior</strong> Strings are immutable UTF-8 sequences wrapped in double quotes. Interpolation placeholders (<code>&lt;binding&gt;</code>) embed previously declared values during evaluation.</p>
<p><strong>Example</strong></p>
<pre><code>name: &quot;Filip&quot;
// -&gt; &quot;Filip&quot;

message: &quot;My name is &lt;name&gt;.&quot;
// -&gt; &quot;My name is Filip.&quot;
</code></pre>
<h2 id="data-types-numbers">Numbers</h2>
<p><strong>Signature</strong> <code>&lt;integer&gt;</code></p>
<p><strong>Behavior</strong> Numbers are 64-bit signed integers. Arithmetic operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>) require numeric operands and return numbers; out-of-range results raise runtime errors.</p>
<p><strong>Example</strong></p>
<pre><code>age: 35
// -&gt; 35

next-year: age + 1
// -&gt; 36
</code></pre>
<h2 id="data-types-boolean">Boolean</h2>
<p><strong>Signature</strong> <code>true | false</code></p>
<p><strong>Behavior</strong> Booleans represent logical truth values. They are the only values accepted by logical operators (<code>&amp;</code>, <code>|</code>) and by functions annotated with the <code>?</code> suffix. Equality compares by value.</p>
<p><strong>Example</strong></p>
<pre><code>flag: true
// -&gt; true

same: flag = true
// -&gt; true
</code></pre>
<h2 id="data-types-null">Null</h2>
<p><strong>Signature</strong> <code>null</code></p>
<p><strong>Behavior</strong> <code>null</code> represents the absence of a value. Property lookups on missing keys yield <code>null</code>, and chaining continues to return <code>null</code> without raising errors. Use <code>defined?</code> to distinguish between present and missing values.</p>
<p><strong>Example</strong></p>
<pre><code>person: { name: &quot;Filip&quot; }

city: person.city
// -&gt; null

foo: null

foo.bar.baz
// -&gt; null
</code></pre>

</section>
<section id="section-operators" data-doc-section="section-operators" data-source="/Users/filipjohansson/dev/fippli/fip/syntax/operators.md">
<h1 id="operators-operators">Operators</h1>
<p>Operators manipulate primitive values, combine expressions, and control evaluation flow. All operators are immutable: they return new values without mutating existing bindings. This guide documents each operator’s signature, behavior, and canonical example.</p>
<h2 id="operators-assignment">Assignment <code>:</code></h2>
<p><strong>Signature</strong> <code>name: expression -&gt; value</code></p>
<p><strong>Behavior</strong> Binds the evaluated expression to <code>name</code> in the current scope. Rebinding the same name in the same scope is illegal; use a new name when deriving additional values. Returns the bound value, enabling pipelines inside composable blocks.</p>
<p><strong>Example</strong></p>
<pre><code>n: 123
// -&gt; 123

name: &quot;Filip&quot;
// -&gt; &quot;Filip&quot;

identity: (x) { x }
// -&gt; &lt;function&gt;
</code></pre>
<h2 id="operators-addition">Addition <code>+</code></h2>
<p><strong>Signature</strong> <code>number + number -&gt; number</code></p>
<p><strong>Behavior</strong> Adds two integers and returns their sum. Both operands must be numbers; otherwise the runtime raises a “Doesn't make sense” error.</p>
<p><strong>Example</strong></p>
<pre><code>1 + 2
// -&gt; 3
</code></pre>
<h2 id="operators-subtraction">Subtraction <code>-</code></h2>
<p><strong>Signature</strong> <code>number - number -&gt; number</code></p>
<p><strong>Behavior</strong> Subtracts the right operand from the left. Operands must be numbers.</p>
<p><strong>Example</strong></p>
<pre><code>5 - 2
// -&gt; 3
</code></pre>
<h2 id="operators-multiplication">Multiplication <code>*</code></h2>
<p><strong>Signature</strong> <code>number * number -&gt; number</code></p>
<p><strong>Behavior</strong> Multiplies two numbers. Inputs must be numeric.</p>
<p><strong>Example</strong></p>
<pre><code>2 * 3
// -&gt; 6
</code></pre>
<h2 id="operators-division">Division <code>/</code></h2>
<p><strong>Signature</strong> <code>number / number -&gt; number</code></p>
<p><strong>Behavior</strong> Divides the left operand by the right. Both operands must be numbers. Division by zero raises a runtime error.</p>
<p><strong>Example</strong></p>
<pre><code>8 / 2
// -&gt; 4
</code></pre>
<h2 id="operators-equality">Equality <code>=</code></h2>
<p><strong>Signature</strong> <code>value = value -&gt; boolean</code></p>
<p><strong>Behavior</strong> Compares two values structurally. Returns <code>true</code> when both operands share the same type and value.</p>
<p><strong>Example</strong></p>
<pre><code>&quot;hello&quot; = &quot;hello&quot;
// -&gt; true
</code></pre>
<h2 id="operators-not-equal">Not equal <code>≠</code></h2>
<p><strong>Signature</strong> <code>value ≠ value -&gt; boolean</code></p>
<p><strong>Behavior</strong> Negates structural equality. Returns <code>true</code> when operands differ.</p>
<p><strong>Example</strong></p>
<pre><code>1 ≠ 2
// -&gt; true
</code></pre>
<h2 id="operators-less-than">Less than <code>&lt;</code></h2>
<p><strong>Signature</strong> <code>number &lt; number -&gt; boolean</code></p>
<p><strong>Behavior</strong> Returns <code>true</code> when the left operand is strictly smaller than the right operand.</p>
<p><strong>Example</strong></p>
<pre><code>3 &lt; 5
// -&gt; true
</code></pre>
<h2 id="operators-greater-than">Greater than <code>&gt;</code></h2>
<p><strong>Signature</strong> <code>number &gt; number -&gt; boolean</code></p>
<p><strong>Behavior</strong> Returns <code>true</code> when the left operand is strictly larger than the right operand.</p>
<p><strong>Example</strong></p>
<pre><code>10 &gt; 1
// -&gt; true
</code></pre>
<h2 id="operators-less-than-or-equal">Less than or equal <code>&lt;=</code></h2>
<p><strong>Signature</strong> <code>number &lt;= number -&gt; boolean</code></p>
<p><strong>Behavior</strong> Returns <code>true</code> when the left operand is smaller than or equal to the right operand.</p>
<p><strong>Example</strong></p>
<pre><code>3 &lt;= 3
// -&gt; true
</code></pre>
<h2 id="operators-greater-than-or-equal">Greater than or equal <code>&gt;=</code></h2>
<p><strong>Signature</strong> <code>number &gt;= number -&gt; boolean</code></p>
<p><strong>Behavior</strong> Returns <code>true</code> when the left operand is larger than or equal to the right operand.</p>
<p><strong>Example</strong></p>
<pre><code>1 &gt;= 10
// -&gt; false
</code></pre>
<h2 id="operators-logical-and">Logical and <code>&amp;</code></h2>
<p><strong>Signature</strong> <code>boolean &amp; boolean -&gt; boolean</code></p>
<p><strong>Behavior</strong> Evaluates both operands and returns <code>true</code> only when both are <code>true</code>. Inputs must be boolean values.</p>
<p><strong>Example</strong></p>
<pre><code>true &amp; false
// -&gt; false
</code></pre>
<h2 id="operators-logical-or">Logical or <code>|</code></h2>
<p><strong>Signature</strong> <code>boolean | boolean -&gt; boolean</code></p>
<p><strong>Behavior</strong> Returns <code>true</code> when either operand is <code>true</code>. Both operands must be booleans.</p>
<p><strong>Example</strong></p>
<pre><code>false | true
// -&gt; true
</code></pre>
<h2 id="operators-spread">Spread <code>...</code></h2><h3 id="operators-object-spread">Object spread</h3>
<p><strong>Signature</strong> <code>{ ...object, key: value } -&gt; object</code></p>
<p><strong>Behavior</strong> Copies fields from one object into a new object. Later fields overwrite earlier ones when keys collide. Source objects remain unchanged.</p>
<p><strong>Example</strong></p>
<pre><code>base: { name: &quot;Jim&quot; }
// -&gt; { name: &quot;Jim&quot; }

with-age: { ...base, age: 100 }
// -&gt; { name: &quot;Jim&quot;, age: 100 }

updated: { ...with-age, age: 75 }
// -&gt; { name: &quot;Jim&quot;, age: 75 }
</code></pre>
<h3 id="operators-array-spread">Array spread</h3>
<p><strong>Signature</strong> <code>[...array, value, ...] -&gt; array</code></p>
<p><strong>Behavior</strong> Expands array elements into a new array literal. The result is a fresh array; the original is unchanged.</p>
<p><strong>Example</strong></p>
<pre><code>a: [1, 2, 3]
// -&gt; [1, 2, 3]

b: [...a, 4, 5]
// -&gt; [1, 2, 3, 4, 5]

c: [0, ...b]
// -&gt; [0, 1, 2, 3, 4, 5]
</code></pre>

</section>
<section id="section-functions" data-doc-section="section-functions" data-source="/Users/filipjohansson/dev/fippli/fip/syntax/functions.md">
<h1 id="functions-functions">Functions</h1>
<p>Functions return the value produced by the final expression in their body. Every function is immutable and curried by default, which means partial application always yields another callable that captures the provided arguments.</p>
<h2 id="functions-definition">Definition</h2>
<p><strong>Signature</strong> <code>&lt;name&gt;: (&lt;parameters&gt;) { &lt;body&gt; }</code></p>
<p><strong>Behavior</strong> Declares an immutable function binding. Parameters are evaluated when the function is called, not when it is defined. The final expression inside the body becomes the return value.</p>
<p><strong>Example</strong></p>
<pre><code>identity: (x) { x }
// -&gt; &lt;function&gt;

identity(42)
// -&gt; 42
</code></pre>
<h3 id="functions-multiple-arguments">Multiple arguments</h3>
<p><strong>Signature</strong> <code>&lt;name&gt;: (param-1, param-2, ...) { &lt;body&gt; }</code></p>
<p><strong>Behavior</strong> Listing multiple parameters is sugar for nesting single-argument functions. The runtime still curries them, so you can call the function with any prefix of arguments.</p>
<p><strong>Example</strong></p>
<pre><code>add: (x, y) { x + y }
// -&gt; &lt;function&gt;

add(1, 2)
// -&gt; 3
</code></pre>
<h3 id="functions-currying">Currying</h3>
<p><strong>Signature</strong> <code>fn(arg-1, arg-2, ...)</code></p>
<p><strong>Behavior</strong> Calling a function with fewer arguments than declared returns a new function that expects the remaining arguments. Supplying all arguments at once works because the interpreter applies them from left to right.</p>
<p><strong>Example</strong></p>
<pre><code>add3: (x, y, z) { x + y + z }
// -&gt; &lt;function&gt;

add1: add3(1)
// -&gt; &lt;function awaiting y, z&gt;

add1-and-2: add1(2)
// -&gt; &lt;function awaiting z&gt;

add1-and-2(3)
// -&gt; 6
</code></pre>
<h2 id="functions-function-call">Function call</h2>
<p><strong>Signature</strong> <code>fn(arg-1, arg-2, ...) -&gt; value</code></p>
<p><strong>Behavior</strong> Evaluates the callee and each argument, then applies them. Curried results can be called immediately or stored for later use.</p>
<p><strong>Example</strong></p>
<pre><code>increment: (x) { x + 1 }
// -&gt; &lt;function&gt;

increment(5)
// -&gt; 6

add: (x, y) { x + y }
// -&gt; &lt;function&gt;

curried: add(10)
// -&gt; &lt;function awaiting y&gt;

curried(7)
// -&gt; 17
</code></pre>
<h2 id="functions-anonymous-functions">Anonymous functions</h2>
<p><strong>Signature</strong> <code>(params) { &lt;body&gt; }</code></p>
<p><strong>Behavior</strong> Defines a function without a name. Anonymous functions obey the same currying and purity rules as named functions and are commonly passed inline to higher-order helpers.</p>
<p><strong>Example</strong></p>
<pre><code>(x) { x * 2 }(3)
// -&gt; 6
</code></pre>
<h3 id="functions-purity-suffixes">Purity suffixes</h3>
<p><strong>Signature</strong> <code>(params)! { &lt;body&gt; } | (params)? { &lt;body&gt; }</code></p>
<p><strong>Behavior</strong> Attach <code>!</code> to mark an anonymous function as impure, or <code>?</code> when it returns a boolean. The interpreter enforces the same suffix rules as for named functions.</p>
<p><strong>Example</strong></p>
<pre><code>numbers: [1, -1, 2]

filter((n)? { n &gt; 0 }, numbers)
// -&gt; [1, 2]

map((n)! {
  trace!(&quot;doubling&quot;, n)
  n + n
}, numbers)
// -&gt; [2, -2, 4]
</code></pre>
<h2 id="functions-composable-blocks">Composable blocks</h2>
<p><strong>Signature</strong> <code>{ expression-1; expression-2; ... }</code></p>
<p><strong>Behavior</strong> Compose operations by stacking expressions—each line feeds the next. This style works well with functions that accept a single argument.</p>
<p><strong>Example</strong></p>
<pre><code>pipeline: (value) {
  value
  increment
  increment
  identity
}
// -&gt; &lt;function&gt;

pipeline(1)
// -&gt; 3
</code></pre>
<h2 id="functions-function-notations">Function notations</h2><h3 id="functions-impure-notation">Impure notation <code>!</code></h3>
<p><strong>Signature</strong> <code>&lt;name&gt;!: (params) { &lt;body&gt; }</code></p>
<p><strong>Behavior</strong> Append <code>!</code> to indicate that a function performs side effects (logging, tracing, IO, etc.). If a function calls any impure helper, it must also use the <code>!</code> suffix. The runtime rejects functions marked with <code>!</code> when no impure calls occur in the body.</p>
<p><strong>Example</strong></p>
<pre><code>logger!: (message) { log!(message) }
// -&gt; &lt;function&gt;

logger!(&quot;hello&quot;)
// -&gt; null
</code></pre>
<h3 id="functions-boolean-notation">Boolean notation <code>?</code></h3>
<p><strong>Signature</strong> <code>&lt;name&gt;?: (params) { &lt;body&gt; }</code></p>
<p><strong>Behavior</strong> Use the <code>?</code> suffix for functions that return a boolean value. A function that does not return a boolean may not use the <code>?</code> suffix.</p>
<p><strong>Example</strong></p>
<pre><code>is-zero?: (x) { x = 0 }
// -&gt; &lt;function&gt;

is-zero?(0)
// -&gt; true
</code></pre>

</section>
<section id="section-core" data-doc-section="section-core" data-source="/Users/filipjohansson/dev/fippli/fip/syntax/core.md">
<h1 id="core-core-functions">Core Functions</h1>
<p>The core module provides a compact standard library that complements the language syntax. Each function is curried: calling it with fewer arguments than listed returns a new function waiting for the remainder. Use the pages under <code>core/</code> for detailed behavior, signatures, and examples.</p>
<h2 id="core-reference-guides">Reference Guides</h2>
<ul>
<li><a href="core/identity.md">Identity</a> — Identity helpers such as <code>identity</code>.</li>
<li><a href="core/values.md">Values</a> — Single-value utilities like <code>.map</code> and <code>defined?</code>.</li>
<li><a href="core/math.md">Math</a> — Numeric utilities including <code>sum</code>, <code>add</code>, <code>subtract</code>, <code>multiply</code>, <code>divide</code>, <code>divide-by</code>, <code>increment</code>, and <code>decrement</code>.</li>
<li><a href="core/array.md">Array Helpers</a> — Collection routines like <code>map</code>, <code>reduce</code>, and predicates.</li>
<li><a href="core/effects.md">Effects</a> — Impure helpers like <code>log!</code>, <code>trace!</code>, and <code>for-each!</code>.</li>
<li><a href="core/control.md">Control</a> — Conditional helpers such as the callable <code>if</code>.</li>
<li><a href="core/object.md">Object Helpers</a> — Reserved for record utilities; update this page as new functions land.</li>
</ul>

</section>
<section id="section-data-structures" data-doc-section="section-data-structures" data-source="/Users/filipjohansson/dev/fippli/fip/syntax/data-structures.md">
<h1 id="data-structures-data-structures">Data Structures</h1>
<p>FIP represents structured data with immutable objects and arrays. These collections support pattern matching through destructuring and can be combined using spread syntax. This page explains how to declare, access, and decompose both forms.</p>
<h2 id="data-structures-objects">Objects</h2>
<p><strong>Signature</strong> <code>{ key: value, ... }</code></p>
<p><strong>Behavior</strong> Objects are immutable maps with string keys. Reassigning a field creates a new object; existing bindings remain untouched. Accessing a missing key returns <code>null</code>, which lets chained lookups short-circuit safely.</p>
<p><strong>Example</strong></p>
<pre><code>person: {
  name: &quot;Filip&quot;,
  age: 35
}

person.name
// -&gt; &quot;Filip&quot;

person.address
// -&gt; null
</code></pre>
<h3 id="data-structures-object-destructuring">Object destructuring</h3>
<p><strong>Signature</strong> <code>{ binding, nested: pattern, ... }: &lt;object&gt;</code></p>
<p><strong>Behavior</strong> Patterns bind values directly from an object into the current scope. Shorthand identifiers pull matching keys, while nested patterns allow deeper extraction. Missing keys bind to <code>null</code> so downstream code can guard with <code>defined?</code>.</p>
<p><strong>Example</strong></p>
<pre><code>{name}: { name: &quot;Mefiboset&quot; }

name
// -&gt; &quot;Mefiboset&quot;

{ profile: { city, country }}: {
  profile: {
    city: &quot;Oslo&quot;,
    country: &quot;Norway&quot;
  }
}

city
// -&gt; &quot;Oslo&quot;

country
// -&gt; &quot;Norway&quot;
</code></pre>
<h2 id="data-structures-arrays">Arrays</h2>
<p><strong>Signature</strong> <code>[value1, value2, ...]</code></p>
<p><strong>Behavior</strong> Arrays store ordered values and never mutate in place. Helpers like <code>map</code>, <code>filter</code>, and <code>reduce</code> return new arrays or aggregated results. Index-based helpers (<code>first</code>, <code>rest</code>, etc.) operate on zero-based positions.</p>
<p><strong>Example</strong></p>
<pre><code>numbers: [1, 2, 5, 6]

numbers
// -&gt; [1, 2, 5, 6]
</code></pre>
<h3 id="data-structures-array-destructuring">Array destructuring</h3>
<p><strong>Signature</strong> <code>[binding1, binding2, ...]: &lt;array&gt;</code></p>
<p><strong>Behavior</strong> Patterns match each array index to a binding. When the array is shorter than the pattern, the remaining bindings receive <code>null</code>. Nested patterns let you destructure arrays of objects or mix array and object extraction in the same statement. Destructuring is currently limited to top-level assignments; function parameters must stay as identifiers.</p>
<p><strong>Example</strong></p>
<pre><code>[first, second]: [10, 20, 30]

first
// -&gt; 10

second
// -&gt; 20

[first, second, third]: [5]

first
// -&gt; 5

second
// -&gt; null

third
// -&gt; null

[{ name }, { name: other-name }]: [
  { name: &quot;Tore&quot; },
  { name: &quot;Knut&quot; }
]

other-name
// -&gt; &quot;Knut&quot;
</code></pre>

</section>
<section id="section-imports" data-doc-section="section-imports" data-source="/Users/filipjohansson/dev/fippli/fip/syntax/imports.md">
<h1 id="imports-imports">Imports</h1>
<p>Fippli programs can pull definitions from other files using the <code>use</code> statement. This enables code splitting across multiple <code>.fip</code> modules while keeping the call sites explicit.</p>
<h2 id="imports-basic-syntax">Basic syntax</h2>
<p><strong>Signature</strong> <code>use &lt;name&gt; from &quot;&lt;module-path&gt;&quot;</code></p>
<p><strong>Behavior</strong> Binds the exported value <code>name</code> from the referenced module path into the current scope. Module paths resolve relative to the program entry point directory (for example, <code>src</code>), not relative to the importing file.</p>
<p><strong>Example</strong></p>
<pre><code>use foo from &quot;lib/foo&quot;
log!(foo())
// -&gt; null
</code></pre>
<h2 id="imports-semantics">Semantics</h2>
<ul>
<li>Each imported file is evaluated once. Subsequent <code>use</code> statements for the same module path reuse the previously computed module environment.</li>
<li>A module must explicitly declare which bindings it exports. Importing a module binds only the exported value associated with the requested name.</li>
<li>Import cycles are detected at runtime; attempting to load modules that depend on each other produces a descriptive error.</li>
</ul>
<h2 id="imports-namespace-imports">Namespace imports</h2>
<p><strong>Signature</strong> <code>use &lt;module&gt; as &lt;alias&gt; from &quot;&lt;module-path&gt;&quot;</code></p>
<p><strong>Behavior</strong> Imports the entire module environment under an alias. Access individual bindings with property notation (<code>alias.increment</code>).</p>
<p><strong>Example</strong></p>
<pre><code>use math as m from &quot;core/math&quot;

m.increment(41)
// -&gt; 42
</code></pre>
<h2 id="imports-selective-imports">Selective imports</h2>
<p><strong>Signature</strong> <code>use { name-1, name-2 } from &quot;&lt;module-path&gt;&quot;</code></p>
<p><strong>Behavior</strong> Imports multiple named exports from the same module. Each listed name must be exported by the target module; missing exports raise a runtime error naming the missing identifier and module path.</p>
<p><strong>Example</strong></p>
<pre><code>use {increment, decrement} from &quot;core/math&quot;

increment(1)
// -&gt; 2

decrement(1)
// -&gt; 0
</code></pre>
<h2 id="imports-error-handling">Error handling</h2>
<ul>
<li>The module file cannot be found at the resolved path.</li>
<li>The module fails to evaluate.</li>
<li>The requested binding is not exported by the module.</li>
<li>An import cycle is encountered.</li>
</ul>
<p>The interpreter raises a runtime error in these cases and includes the original <code>use</code> site plus the attempted module path to aid debugging.</p>

</section>
<section id="section-errors" data-doc-section="section-errors" data-source="/Users/filipjohansson/dev/fippli/fip/syntax/errors.md">
<h1 id="errors-errors">Errors</h1>
<p>Runtime errors include a descriptive message that explains what went wrong and how to correct it. Errors do not recover automatically; they terminate the current evaluation unless tooling catches them.</p>
<h2 id="errors-doesnt-make-sense">Doesn't make sense</h2>
<p><strong>Signature</strong> <code>Doesn't make sense: &lt;explanation&gt;</code></p>
<p><strong>Behavior</strong> Raised when an operator is applied to operands of incompatible types. Arithmetic operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>) only accept numbers, and logical operators (<code>&amp;</code>, <code>|</code>) only accept booleans. The error message identifies the operator and operand types.</p>
<p><strong>Example</strong></p>
<pre><code>1 + &quot;some string&quot;
// -&gt; Doesn't make sense: cannot add Number and String

true - false
// -&gt; Doesn't make sense: cannot subtract Boolean values
</code></pre>
<h2 id="errors-suffix-error">Suffix error</h2>
<p><strong>Signature</strong> <code>Suffix error: &lt;explanation&gt;</code></p>
<p><strong>Behavior</strong> Raised when a function definition misuses the impure <code>!</code> suffix or boolean <code>?</code> suffix. Pure bodies marked <code>!</code> and non-boolean bodies marked <code>?</code> both trigger this error. The message names the offending function.</p>
<p><strong>Example</strong></p>
<pre><code>pure!: (x) { x + 1 }
// -&gt; Suffix error: function marked ! but body has no impure calls

is-sum?: (x, y) { x + y }
// -&gt; Suffix error: function marked ? but body does not return a Boolean
</code></pre>
<h2 id="errors-mutation-error">Mutation error</h2>
<p><strong>Signature</strong> <code>Mutation error: trying to mutate binding &lt;name&gt;</code></p>
<p><strong>Behavior</strong> Raised when attempting to redefine a binding that already exists in the current scope. FIP bindings are immutable, so once a name is bound to a value, it cannot be reassigned. Use a new identifier to represent a different value.</p>
<p><strong>Example</strong></p>
<pre><code>x: 1
x: 2
// -&gt; Mutation error: trying to mutate binding x

count: 3
count: count + 1
// -&gt; Mutation error: trying to mutate binding count
</code></pre>

</section>
<section id="section-comments" data-doc-section="section-comments" data-source="/Users/filipjohansson/dev/fippli/fip/syntax/comments.md">
<h1 id="comments-comments">Comments</h1>
<p>Comments document intent without affecting evaluation. They are stripped by the lexer before parsing, so they never change runtime behavior. Use them to explain tricky logic or annotate pipelines for future readers.</p>
<h2 id="comments-single-line-comments">Single-line comments</h2>
<p><strong>Signature</strong> <code>// &lt;text&gt;</code></p>
<p><strong>Behavior</strong> Everything after <code>//</code> on the same line is ignored. Comments may appear on their own line or after an expression. There is no block comment syntax; prefer multiple single-line comments for longer notes.</p>
<p><strong>Example</strong></p>
<pre><code>// This line does nothing
log!(&quot;visible output&quot;) // trailing comments work too
// -&gt; null
</code></pre>

</section>
<section id="section-array" data-doc-section="section-array" data-source="/Users/filipjohansson/dev/fippli/fip/syntax/core/array.md">
<h1 id="array-core-array-helpers">Core Array Helpers</h1>
<p>Array helpers operate on ordered collections (<code>[ ... ]</code>). Unless otherwise noted they never mutate their inputs and return new arrays. See <a href="../data-types.md">data-types</a> for collection semantics and <a href="../functions.md">functions</a> for details on currying.</p>
<h2 id="array-map">map</h2>
<p><strong>Signature</strong> <code>map: (fn, array) -&gt; array</code></p>
<p><strong>Behavior</strong> Produces a new array by invoking <code>fn</code> on each element of <code>array</code> from left to right. <code>fn</code> receives the current element and must return the transformed value. The original array is left untouched.</p>
<p><strong>Example</strong></p>
<pre><code>numbers: [1, 2, 3]

map(increment, numbers)
// -&gt; [2, 3, 4]
</code></pre>
<h2 id="array-reduce">reduce</h2>
<p><strong>Signature</strong> <code>reduce: (fn, init, array) -&gt; value</code></p>
<p><strong>Behavior</strong> Folds <code>array</code> into a single value. <code>fn</code> is called with <code>(accumulator, element)</code> for each element, starting with <code>init</code> as the first accumulator. The last accumulator returned by <code>fn</code> becomes the result and empty arrays immediately return <code>init</code>.</p>
<p><strong>Example</strong></p>
<pre><code>numbers: [1, 2, 3]

reduce((acc, n) { acc + n }, 0, numbers)
// -&gt; 6
</code></pre>
<h2 id="array-filter">filter</h2>
<p><strong>Signature</strong> <code>filter: (predicate, array) -&gt; array</code></p>
<p><strong>Behavior</strong> Returns a new array containing only the elements for which <code>predicate(element)</code> returns <code>true</code>. Preserves the original order.</p>
<p><strong>Example</strong></p>
<pre><code>numbers: [1, 2, 3]

is-two?: (n) { n = 2 }
// -&gt; &lt;function&gt;

filter(is-two?, numbers)
// -&gt; [2]
</code></pre>
<h2 id="array-every">every?</h2>
<p><strong>Signature</strong> <code>every?: (predicate, array) -&gt; boolean</code></p>
<p><strong>Behavior</strong> Returns <code>true</code> if <code>predicate(element)</code> is <code>true</code> for every element of <code>array</code>. Returns <code>true</code> for an empty array and stops early on the first <code>false</code>.</p>
<p><strong>Example</strong></p>
<pre><code>numbers: [2, 4, 6]

is-even?: (n) { n % 2 = 0 }
// -&gt; &lt;function&gt;

every?(is-even?, numbers)
// -&gt; true
</code></pre>
<h2 id="array-some">some?</h2>
<p><strong>Signature</strong> <code>some?: (predicate, array) -&gt; boolean</code></p>
<p><strong>Behavior</strong> Returns <code>true</code> if <code>predicate(element)</code> is <code>true</code> for at least one element of <code>array</code>. Returns <code>false</code> for an empty array and stops early on the first <code>true</code>.</p>
<p><strong>Example</strong></p>
<pre><code>numbers: [1, 2, 3]

some?((n) { n = 2 }, numbers)
// -&gt; true
</code></pre>
<h2 id="array-none">none?</h2>
<p><strong>Signature</strong> <code>none?: (predicate, array) -&gt; boolean</code></p>
<p><strong>Behavior</strong> Returns <code>true</code> if <code>predicate(element)</code> is <code>false</code> for every element of <code>array</code>. Equivalent to <code>not(every?(predicate, array))</code> and returns <code>true</code> for an empty array.</p>
<p><strong>Example</strong></p>
<pre><code>numbers: [1, 3, 5]

none?((n) { n % 2 = 0 }, numbers)
// -&gt; true
</code></pre>

</section>
<section id="section-control" data-doc-section="section-control" data-source="/Users/filipjohansson/dev/fippli/fip/syntax/core/control.md">
<h1 id="control-core-control">Core Control</h1>
<p>Control helpers decide which branch of a computation should run. They complement the language-level <code>if</code> expression discussed in <a href="../errors.md">syntax/errors.md</a> by documenting the callable form exposed by the core module.</p>
<h2 id="control-if">if</h2>
<p><strong>Signature</strong> <code>if: (condition, then-fn, else-fn) -&gt; value</code></p>
<p><strong>Behavior</strong> Evaluates <code>condition</code>, which must be a boolean. Invokes <code>then-fn()</code> when <code>condition</code> is <code>true</code>, otherwise <code>else-fn()</code>. Only the chosen branch runs and its return value becomes the result. Both thunks must be pure or impure together with the surrounding context.</p>
<p><strong>Example</strong></p>
<pre><code>result-true: if(true, () { &quot;true&quot; }, () { &quot;false&quot; })
// -&gt; &quot;true&quot;

maybe-value: 12345
// -&gt; 12345

safe: if(defined?(maybe-value), () { maybe-value }, () { &quot;No value&quot; })
// -&gt; 12345

missing: null
// -&gt; null

fallback: if(defined?(missing), () { missing }, () { &quot;No value&quot; })
// -&gt; &quot;No value&quot;
</code></pre>

</section>
<section id="section-effects" data-doc-section="section-effects" data-source="/Users/filipjohansson/dev/fippli/fip/syntax/core/effects.md">
<h1 id="effects-core-effects">Core Effects</h1>
<p>The core effects module exposes impure helpers that interact with the outside world or sequence evaluation. Each function carries a <code>!</code> suffix and must run in an impure context. For an overview of purity, see <a href="../errors.md">errors</a> and <a href="../functions.md">functions</a>.</p>
<h2 id="effects-log">log!</h2>
<p><strong>Signature</strong> <code>log!: (message) -&gt; null</code></p>
<p><strong>Behavior</strong> Writes <code>message</code> to standard output and returns <code>null</code>. Use it for quick diagnostics or user feedback without altering program state. Never throws and ignores its return value in pipelines.</p>
<p><strong>Example</strong></p>
<pre><code>log!(&quot;hello, world&quot;)
// -&gt; null
</code></pre>
<h2 id="effects-trace">trace!</h2>
<p><strong>Signature</strong> <code>trace!: (label, value) -&gt; value</code></p>
<p><strong>Behavior</strong> Prints <code>(trace) &lt;label&gt;: &lt;value&gt;</code> to standard output and returns <code>value</code> unchanged so it can stay in a pipeline. Impure because it performs IO but otherwise side-effect free.</p>
<p><strong>Example</strong></p>
<pre><code>trace!(&quot;name&quot;, &quot;Filip&quot;)
// -&gt; &quot;Filip&quot;
</code></pre>
<h2 id="effects-for-each">for-each!</h2>
<p><strong>Signature</strong> <code>for-each!: (fn, array) -&gt; null</code></p>
<p><strong>Behavior</strong> Iterates through <code>array</code> from left to right, invoking the single-argument impure function <code>fn</code> for each element. Any value returned by <code>fn</code> is ignored. <code>for-each!</code> sequences side effects, always returns <code>null</code>, and propagates errors thrown by <code>fn</code>.</p>
<p><strong>Example</strong></p>
<pre><code>words: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]

for-each!((word)! { log!(word) }, words)
// -&gt; null
</code></pre>

</section>
<section id="section-identity" data-doc-section="section-identity" data-source="/Users/filipjohansson/dev/fippli/fip/syntax/core/identity.md">
<h1 id="identity-core-identity">Core Identity</h1>
<p>Identity helpers preserve or check values without transforming them. They are useful in pipelines, conditional guards, and when bridging impure and pure code. Review <a href="../functions.md">functions</a> for details on currying and invocation syntax.</p>
<h2 id="identity-identity">identity</h2>
<p><strong>Signature</strong> <code>identity: (x) -&gt; x</code></p>
<p><strong>Behavior</strong> Returns the provided argument unchanged. Often used as a default callback or to reset a pipeline.</p>
<p><strong>Example</strong></p>
<pre><code>identity(&quot;hello&quot;)
// -&gt; &quot;hello&quot;
</code></pre>

</section>
<section id="section-math" data-doc-section="section-math" data-source="/Users/filipjohansson/dev/fippli/fip/syntax/core/math.md">
<h1 id="math-core-math">Core Math</h1>
<p>The math helpers provide simple numeric transformations. All functions assume their arguments are numbers and rely on the runtime's numeric type semantics discussed in <a href="../data-types.md">data-types</a>.</p>
<h2 id="math-add">add</h2>
<p><strong>Signature</strong> <code>add: (lhs, rhs) -&gt; number</code></p>
<p><strong>Behavior</strong> Returns the sum of <code>lhs</code> and <code>rhs</code>. Both inputs must be numeric. Supports partial application: supplying only <code>lhs</code> returns a function that awaits <code>rhs</code>.</p>
<p><strong>Example</strong></p>
<pre><code>add(2, 3)
// -&gt; 5

add-five: add(5)
// -&gt; &lt;function&gt;

add-five(10)
// -&gt; 15
</code></pre>
<h2 id="math-subtract">subtract</h2>
<p><strong>Signature</strong> <code>subtract: (lhs, rhs) -&gt; number</code></p>
<p><strong>Behavior</strong> Returns the result of <code>lhs - rhs</code>. Both inputs must be numeric. Partial application yields a function that subtracts its argument from the captured <code>lhs</code>.</p>
<p><strong>Example</strong></p>
<pre><code>subtract(7, 2)
// -&gt; 5

decrease-from-ten: subtract(10)
// -&gt; &lt;function&gt;

decrease-from-ten(3)
// -&gt; 7
</code></pre>
<h2 id="math-multiply">multiply</h2>
<p><strong>Signature</strong> <code>multiply: (lhs, rhs) -&gt; number</code></p>
<p><strong>Behavior</strong> Returns the product of <code>lhs</code> and <code>rhs</code>. Both arguments must be numeric. Works with partial application for creating reusable scalars.</p>
<p><strong>Example</strong></p>
<pre><code>multiply(4, 3)
// -&gt; 12

double: multiply(2)
// -&gt; &lt;function&gt;

double(6)
// -&gt; 12
</code></pre>
<h2 id="math-divide">divide</h2>
<p><strong>Signature</strong> <code>divide: (lhs, rhs) -&gt; number</code></p>
<p><strong>Behavior</strong> Returns the quotient of <code>lhs / rhs</code>. Both arguments must be numeric. Raises a runtime error if <code>rhs</code> is zero. Partial application is useful for building reciprocal helpers.</p>
<p><strong>Example</strong></p>
<pre><code>divide(12, 3)
// -&gt; 4

divide-from-hundred: divide(100)
// -&gt; &lt;function&gt;

divide-from-hundred(4)
// -&gt; 25
</code></pre>
<h2 id="math-divide-by">divide-by</h2>
<p><strong>Signature</strong> <code>divide-by: (denominator, numerator) -&gt; number</code></p>
<p><strong>Behavior</strong> Divides <code>numerator</code> by <code>denominator</code>, reversing the argument order compared to <code>divide</code>. Useful when piping a value that should become the numerator. Errors if <code>denominator</code> is zero.</p>
<p><strong>Example</strong></p>
<pre><code>divide-by(2, 4)
// -&gt; 2

halve: divide-by(2)
// -&gt; &lt;function&gt;

halve(9)
// -&gt; 4.5

result: (
  4
  divide-by(2)
)
// -&gt; 2
</code></pre>
<h2 id="math-increment">increment</h2>
<p><strong>Signature</strong> <code>increment: (number) -&gt; number</code></p>
<p><strong>Behavior</strong> Adds one to the numeric argument. Errors if the argument is not numeric.</p>
<p><strong>Example</strong></p>
<pre><code>increment(3)
// -&gt; 4
</code></pre>
<h2 id="math-decrement">decrement</h2>
<p><strong>Signature</strong> <code>decrement: (number) -&gt; number</code></p>
<p><strong>Behavior</strong> Subtracts one from the numeric argument. Errors if the argument is not numeric.</p>
<p><strong>Example</strong></p>
<pre><code>decrement(3)
// -&gt; 2
</code></pre>

</section>
<section id="section-object" data-doc-section="section-object" data-source="/Users/filipjohansson/dev/fippli/fip/syntax/core/object.md">
<h1 id="object-core-object-helpers">Core Object Helpers</h1>
<p>The core module exposes object utilities for working with records. No standalone helpers are available yet, but this page reserves the canonical location for future additions. When new functions ship, document them here following the standard Signature, Behavior, and Example sections.</p>

</section>
<section id="section-values" data-doc-section="section-values" data-source="/Users/filipjohansson/dev/fippli/fip/syntax/core/values.md">
<h1 id="values-core-values">Core Values</h1>
<p>Value helpers operate on single data items rather than whole collections. They are designed for use in pipelines and guards where you want to transform or validate the current value. See <a href="../functions.md">functions</a> for currying semantics and <a href="../data-types.md">data-types</a> for runtime value rules.</p>
<h2 id="values-map">.map</h2>
<p><strong>Signature</strong> <code>.map: (fn, value) -&gt; value</code></p>
<p><strong>Behavior</strong> Applies <code>fn</code> to the provided <code>value</code> and returns the result. This lets you treat a lone value as a one-item collection inside a pipeline without breaking fluent APIs.</p>
<p><strong>Implementation Notes</strong></p>
<ul>
<li>Accept a callable <code>fn</code> and any <code>value</code>.</li>
<li>Invoke <code>fn(value)</code> in the current purity context; propagate errors and purity requirements.</li>
<li>Ensure <code>fn</code> expects exactly one argument.</li>
<li>Return the result of the invocation without modification.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code>.map(increment, 1)
// -&gt; 2

enrich: () {
  { name: &quot;Filip&quot;, age: 35, city: &quot;Oslo&quot; }
  .map((person) {
    {
      ...person
      name: &quot;&lt;person.name&gt; Johansson&quot;
    }
  })
  .map((person) {
    {
      ...person
      age: person.age + 1
    }
  })
  .map((person) {
    {
      ...person
      city: &quot;New &lt;person.city&gt;&quot;
    }
  })
}
// -&gt; &lt;function&gt;

enrich()
// -&gt; { name: &quot;Filip Johansson&quot;, age: 36, city: &quot;New Oslo&quot; }
</code></pre>
<h2 id="values-defined">defined?</h2>
<p><strong>Signature</strong> <code>defined?: (value) -&gt; boolean</code></p>
<p><strong>Behavior</strong> Returns <code>false</code> when <code>value</code> is <code>null</code>, otherwise <code>true</code>. Use it to guard optional data before dereferencing or branching.</p>
<p><strong>Example</strong></p>
<pre><code>defined?(null)
// -&gt; false

defined?(123)
// -&gt; true
</code></pre>

</section>

    </main>
  </body>
</html>
